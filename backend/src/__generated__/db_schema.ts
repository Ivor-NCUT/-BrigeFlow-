// ----------------------------------------------------------------
// ðŸ›‘ AUTO-GENERATED FILE - DO NOT EDIT!
// Regenerated by: edgespark pull schema --db
//
// To modify your database schema (multiple statements in one command):
//   edgespark db sql "CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT);
//     CREATE TABLE posts (id INTEGER PRIMARY KEY, user_id INTEGER REFERENCES users(id), created_at INTEGER);
//     CREATE INDEX idx_posts_created ON posts(created_at)"
//
// To query your database:
//   edgespark db sql "SELECT * FROM posts; SELECT COUNT(*) FROM users"
// ----------------------------------------------------------------

import { sqliteTable, AnySQLiteColumn, uniqueIndex, text, integer, index, foreignKey, numeric, primaryKey } from "drizzle-orm/sqlite-core"
  import { sql } from "drizzle-orm"

export const esSystemAuthUser = sqliteTable("es_system__auth_user", {
	id: text().primaryKey().notNull(),
	name: text().notNull(),
	email: text().notNull(),
	emailVerified: integer("email_verified").default(0).notNull(),
	image: text(),
	createdAt: integer("created_at").default(sql`(cast(unixepoch('subsecond') * 1000 as integer))`).notNull(),
	updatedAt: integer("updated_at").default(sql`(cast(unixepoch('subsecond') * 1000 as integer))`).notNull(),
	isAnonymous: integer("is_anonymous").default(0),
	internalA: text("__internal_a"),
	banned: integer().default(0),
	banReason: text("ban_reason"),
	banExpires: integer("ban_expires"),
	lastLoginAt: integer("last_login_at"),
},
(table) => [
	uniqueIndex("es_system__auth_user_email_unique").on(table.email),
]);

export const connections = sqliteTable("connections", {
	id: text().primaryKey(),
	sourceContactId: text("source_contact_id").notNull().references(() => contacts.id, { onDelete: "cascade" } ),
	targetContactId: text("target_contact_id").notNull().references(() => contacts.id, { onDelete: "cascade" } ),
	type: text(),
},
(table) => [
	index("connections_source_idx").on(table.sourceContactId),
]);

export const contacts = sqliteTable("contacts", {
	id: text().primaryKey(),
	userId: text("user_id").notNull(),
	name: text().notNull(),
	avatar: text(),
	title: text(),
	company: text(),
	bonjourLink: text("bonjour_link"),
	notes: text(),
	createdAt: text("created_at").notNull(),
	lastContactedAt: text("last_contacted_at").notNull(),
	interactionCount: integer("interaction_count").default(0),
	shareVisible: numeric("share_visible"),
	sensitiveNotes: text("sensitive_notes"),
},
(table) => [
	index("contacts_user_id_idx").on(table.userId),
]);

export const tags = sqliteTable("tags", {
	id: text().primaryKey(),
	userId: text("user_id").notNull(),
	label: text().notNull(),
	category: text().notNull(),
	color: text().notNull(),
},
(table) => [
	index("tags_user_id_idx").on(table.userId),
]);

export const contactTags = sqliteTable("contact_tags", {
	contactId: text("contact_id").notNull(),
	tagId: text("tag_id").notNull(),
},
(table) => [
	primaryKey({ columns: [table.contactId, table.tagId], name: "contact_tags_contact_id_tag_id_pk"})
]);

export const communicationRecords = sqliteTable("communication_records", {
	id: text().primaryKey(),
	contactId: text("contact_id").notNull(),
	date: text().notNull(),
	type: text().notNull(),
	summary: text().notNull(),
	details: text(),
	followUpDate: text("follow_up_date"),
	followUpNote: text("follow_up_note"),
	followUpDone: numeric("follow_up_done"),
},
(table) => [
	index("comm_records_contact_id_idx").on(table.contactId),
]);

export const relationships = sqliteTable("relationships", {
	id: text().primaryKey(),
	userId: text("user_id").notNull(),
	sourceContactId: text("source_contact_id").notNull(),
	targetContactId: text("target_contact_id").notNull(),
	type: text(),
	strength: integer().default(1),
	createdAt: integer("created_at").default(sql`(unixepoch())`),
},
(table) => [
	index("idx_relationships_target").on(table.targetContactId),
	index("idx_relationships_source").on(table.sourceContactId),
	index("idx_relationships_user_id").on(table.userId),
]);

